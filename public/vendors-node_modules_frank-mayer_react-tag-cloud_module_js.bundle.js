/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkportfolio"] = self["webpackChunkportfolio"] || []).push([["vendors-node_modules_frank-mayer_react-tag-cloud_module_js"],{

/***/ "./node_modules/@frank-mayer/react-tag-cloud/module.js":
/*!*************************************************************!*\
  !*** ./node_modules/@frank-mayer/react-tag-cloud/module.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TagCloud: () => (/* binding */ $d415641d0cfd8c85$export$61a620005b8c73bd),\n/* harmony export */   \"default\": () => (/* binding */ $d415641d0cfd8c85$export$2e2bcd8739ae039)\n/* harmony export */ });\n/* harmony import */ var TagCloud__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! TagCloud */ \"./node_modules/TagCloud/dist/TagCloud.js\");\n/* harmony import */ var TagCloud__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(TagCloud__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst $d415641d0cfd8c85$var$getIsInitialized = id => {\n  const key = \"__tag-cloud-\" + id;\n  if (key in window) return Boolean(window[key]);\n  return window[key] = false;\n};\nconst $d415641d0cfd8c85$var$setIsInitialized = (id, value) => {\n  const key = \"__tag-cloud-\" + id;\n  window[key] = value;\n};\nconst $d415641d0cfd8c85$export$61a620005b8c73bd = props => {\n  const ref = (0, react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const key = [props.id, props.className, JSON.stringify(props.children)].join(\"-\");\n  (0, react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if ($d415641d0cfd8c85$var$getIsInitialized(key) || !ref.current) return;\n    if (props.children.length === 0) {\n      console.error(\"TagCloud: No children provided.\");\n      return;\n    }\n    const options = props.options ? typeof props.options == \"function\" ? props.options(window) : props.options : {};\n    const tagCloud = (0, (TagCloud__WEBPACK_IMPORTED_MODULE_0___default()))(ref.current, props.children, options);\n    $d415641d0cfd8c85$var$setIsInitialized(key, true);\n    if (props.onClick) {\n      const elements = Array.from(ref.current.getElementsByClassName(options.itemClass ?? \"tagcloud--item\"));\n      if (props.onClick) for (const el of elements) el.addEventListener(\"click\", event => {\n        props.onClick(el.innerText, event);\n      }, props.onClickOptions);\n    }\n    return () => {\n      try {\n        tagCloud?.destroy();\n      } finally {\n        $d415641d0cfd8c85$var$setIsInitialized(key, false);\n      }\n    };\n  }, [ref, key, props]);\n  return (0, react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    id: props.id,\n    className: props.className,\n    style: props.style,\n    ref: ref\n  });\n};\nvar $d415641d0cfd8c85$export$2e2bcd8739ae039 = $d415641d0cfd8c85$export$61a620005b8c73bd;\n\n\n//# sourceURL=webpack://portfolio/./node_modules/@frank-mayer/react-tag-cloud/module.js?");

/***/ }),

/***/ "./node_modules/TagCloud/dist/TagCloud.js":
/*!************************************************!*\
  !*** ./node_modules/TagCloud/dist/TagCloud.js ***!
  \************************************************/
/***/ (function(module) {

eval("/*!\n * TagCloud.js v2.4.0\n * Copyright (c) 2016-2023 @ Cong Min\n * MIT License - https://github.com/mcc108/TagCloud\n */\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  'use strict';\n\n  function ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var o = Object.getOwnPropertySymbols(e);\n      r && (o = o.filter(function (r) {\n        return Object.getOwnPropertyDescriptor(e, r).enumerable;\n      })), t.push.apply(t, o);\n    }\n    return t;\n  }\n  function _objectSpread2(e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = null != arguments[r] ? arguments[r] : {};\n      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n        _defineProperty(e, r, t[r]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n      });\n    }\n    return e;\n  }\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n  function _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n\n  /**\n   * TagCloud.js (c) 2016-2019 @ Cong Min\n   * MIT License - https://github.com/cong-min/TagCloud\n   */\n  var TagCloud = /*#__PURE__*/function () {\n    /* constructor */\n    function TagCloud() {\n      var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.body;\n      var texts = arguments.length > 1 ? arguments[1] : undefined;\n      var options = arguments.length > 2 ? arguments[2] : undefined;\n      _classCallCheck(this, TagCloud);\n      var self = this;\n      if (!container || container.nodeType !== 1) return new Error('Incorrect element type');\n\n      // params\n      self.$container = container;\n      self.texts = texts || [];\n      self.config = _objectSpread2(_objectSpread2({}, TagCloud._defaultConfig), options || {});\n\n      // calculate config\n      self.radius = self.config.radius; // rolling radius\n      self.depth = 2 * self.radius; // rolling depth\n      self.size = 1.5 * self.radius; // rolling area size with mouse\n      self.maxSpeed = TagCloud._getMaxSpeed(self.config.maxSpeed); // rolling max speed\n      self.initSpeed = TagCloud._getInitSpeed(self.config.initSpeed); // rolling init speed\n      self.direction = self.config.direction; // rolling init direction\n      self.keep = self.config.keep; // whether to keep rolling after mouse out area\n      self.paused = false; // keep state to pause the animation\n\n      // create element\n      self._createElment();\n      // init\n      self._init();\n      // set elements and instances\n      TagCloud.list.push({\n        el: self.$el,\n        container: container,\n        instance: self\n      });\n    }\n\n    /* static method */\n    // all TagCloud list\n    _createClass(TagCloud, [{\n      key: \"_createElment\",\n      value: /* instance property method */\n      // create elment\n      function _createElment() {\n        var self = this;\n\n        // create container\n        var $el = document.createElement('div');\n        $el.className = self.config.containerClass;\n        if (self.config.useContainerInlineStyles) {\n          $el.style.position = 'relative';\n          $el.style.width = \"\".concat(2 * self.radius, \"px\");\n          $el.style.height = \"\".concat(2 * self.radius, \"px\");\n        }\n\n        // create texts\n        self.items = [];\n        self.texts.forEach(function (text, index) {\n          var item = self._createTextItem(text, index);\n          $el.appendChild(item.el);\n          self.items.push(item);\n        });\n        self.$container.appendChild($el);\n        self.$el = $el;\n      }\n\n      // create a text\n    }, {\n      key: \"_createTextItem\",\n      value: function _createTextItem(text) {\n        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var self = this;\n        var itemEl = document.createElement('span');\n        itemEl.className = self.config.itemClass;\n        if (self.config.useItemInlineStyles) {\n          itemEl.style.willChange = 'transform, opacity, filter';\n          itemEl.style.position = 'absolute';\n          itemEl.style.top = '50%';\n          itemEl.style.left = '50%';\n          itemEl.style.zIndex = index + 1;\n          itemEl.style.filter = 'alpha(opacity=0)';\n          itemEl.style.opacity = 0;\n          var transformOrigin = '50% 50%';\n          itemEl.style.WebkitTransformOrigin = transformOrigin;\n          itemEl.style.MozTransformOrigin = transformOrigin;\n          itemEl.style.OTransformOrigin = transformOrigin;\n          itemEl.style.transformOrigin = transformOrigin;\n          var transform = 'translate3d(-50%, -50%, 0) scale(1)';\n          itemEl.style.WebkitTransform = transform;\n          itemEl.style.MozTransform = transform;\n          itemEl.style.OTransform = transform;\n          itemEl.style.transform = transform;\n        }\n        if (self.config.useHTML) {\n          itemEl.innerHTML = text;\n        } else {\n          itemEl.innerText = text;\n        }\n        return _objectSpread2({\n          el: itemEl\n        }, self._computePosition(index));\n      }\n\n      // calculate appropriate place\n    }, {\n      key: \"_computePosition\",\n      value: function _computePosition(index) {\n        var random = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var self = this;\n        var textsLength = self.texts.length;\n        // if random `true`, It means that a random appropriate place is generated, and the position will be independent of `index`\n        if (random) index = Math.floor(Math.random() * (textsLength + 1));\n        var phi = Math.acos(-1 + (2 * index + 1) / textsLength);\n        var theta = Math.sqrt((textsLength + 1) * Math.PI) * phi;\n        return {\n          x: self.size * Math.cos(theta) * Math.sin(phi) / 2,\n          y: self.size * Math.sin(theta) * Math.sin(phi) / 2,\n          z: self.size * Math.cos(phi) / 2\n        };\n      }\n    }, {\n      key: \"_requestInterval\",\n      value: function _requestInterval(fn, delay) {\n        var requestAnimFrame = (function () {\n          return window.requestAnimationFrame;\n        } || function (callback, element) {\n          window.setTimeout(callback, 1000 / 60);\n        })();\n        var start = new Date().getTime();\n        var handle = {};\n        function loop() {\n          handle.value = requestAnimFrame(loop);\n          var current = new Date().getTime(),\n            delta = current - start;\n          if (delta >= delay) {\n            fn.call();\n            start = new Date().getTime();\n          }\n        }\n        handle.value = requestAnimFrame(loop);\n        return handle;\n      }\n\n      // init\n    }, {\n      key: \"_init\",\n      value: function _init() {\n        var self = this;\n        self.active = false; // whether the mouse is activated\n\n        self.mouseX0 = self.initSpeed * Math.sin(self.direction * (Math.PI / 180)); // init distance between the mouse and rolling center x axis\n        self.mouseY0 = -self.initSpeed * Math.cos(self.direction * (Math.PI / 180)); // init distance between the mouse and rolling center y axis\n\n        self.mouseX = self.mouseX0; // current distance between the mouse and rolling center x axis\n        self.mouseY = self.mouseY0; // current distance between the mouse and rolling center y axis\n\n        var isTouchDevice = window.matchMedia('(hover: hover)');\n        if (!isTouchDevice || isTouchDevice.matches) {\n          // mouseover\n          TagCloud._on(self.$el, 'mouseover', function () {\n            self.active = true;\n          });\n          // mouseout\n          TagCloud._on(self.$el, 'mouseout', function () {\n            self.active = false;\n          });\n          // mousemove\n          TagCloud._on(self.keep ? window : self.$el, 'mousemove', function (ev) {\n            ev = ev || window.event;\n            var rect = self.$el.getBoundingClientRect();\n            self.mouseX = (ev.clientX - (rect.left + rect.width / 2)) / 5;\n            self.mouseY = (ev.clientY - (rect.top + rect.height / 2)) / 5;\n          });\n        }\n\n        // update state regularly\n        self._next(); // init update state\n        self.interval = self._requestInterval(function () {\n          self._next.call(self);\n        }, 10);\n      }\n\n      // calculate the next state\n    }, {\n      key: \"_next\",\n      value: function _next() {\n        var self = this;\n        if (self.paused) {\n          return;\n        }\n\n        // if keep `false`, pause rolling after moving mouse out area\n        if (!self.keep && !self.active) {\n          self.mouseX = Math.abs(self.mouseX - self.mouseX0) < 1 ? self.mouseX0 : (self.mouseX + self.mouseX0) / 2; // reset distance between the mouse and rolling center x axis\n          self.mouseY = Math.abs(self.mouseY - self.mouseY0) < 1 ? self.mouseY0 : (self.mouseY + self.mouseY0) / 2; // reset distance between the mouse and rolling center y axis\n        }\n        var a = -(Math.min(Math.max(-self.mouseY, -self.size), self.size) / self.radius) * self.maxSpeed;\n        var b = Math.min(Math.max(-self.mouseX, -self.size), self.size) / self.radius * self.maxSpeed;\n        if (Math.abs(a) <= 0.01 && Math.abs(b) <= 0.01) return; // pause\n\n        // calculate offset\n        var l = Math.PI / 180;\n        var sc = [Math.sin(a * l), Math.cos(a * l), Math.sin(b * l), Math.cos(b * l)];\n        self.items.forEach(function (item) {\n          var rx1 = item.x;\n          var ry1 = item.y * sc[1] + item.z * -sc[0];\n          var rz1 = item.y * sc[0] + item.z * sc[1];\n          var rx2 = rx1 * sc[3] + rz1 * sc[2];\n          var ry2 = ry1;\n          var rz2 = rz1 * sc[3] - rx1 * sc[2];\n          var per = 2 * self.depth / (2 * self.depth + rz2); // todo\n\n          item.x = rx2;\n          item.y = ry2;\n          item.z = rz2;\n          item.scale = per.toFixed(3);\n          var alpha = per * per - 0.25;\n          alpha = (alpha > 1 ? 1 : alpha).toFixed(3);\n          var itemEl = item.el;\n          var left = (item.x - itemEl.offsetWidth / 2).toFixed(2);\n          var top = (item.y - itemEl.offsetHeight / 2).toFixed(2);\n          var transform = \"translate3d(\".concat(left, \"px, \").concat(top, \"px, 0) scale(\").concat(item.scale, \")\");\n          itemEl.style.WebkitTransform = transform;\n          itemEl.style.MozTransform = transform;\n          itemEl.style.OTransform = transform;\n          itemEl.style.transform = transform;\n          itemEl.style.filter = \"alpha(opacity=\".concat(100 * alpha, \")\");\n          itemEl.style.opacity = alpha;\n        });\n      }\n\n      /* export instance properties and methods */\n      // update\n    }, {\n      key: \"update\",\n      value: function update(texts) {\n        var self = this;\n        // params\n        self.texts = texts || [];\n        // judging and processing items based on texts\n        self.texts.forEach(function (text, index) {\n          var item = self.items[index];\n          if (!item) {\n            // if not had, then create\n            item = self._createTextItem(text, index);\n            _extends(item, self._computePosition(index, true)); // random place\n            self.$el.appendChild(item.el);\n            self.items.push(item);\n          }\n          // if had, replace text\n          if (self.config.useHTML) {\n            item.el.innerHTML = text;\n          } else {\n            item.el.innerText = text;\n          }\n        });\n        // remove redundant self.items\n        var textsLength = self.texts.length;\n        var itemsLength = self.items.length;\n        if (textsLength < itemsLength) {\n          var removeList = self.items.splice(textsLength, itemsLength - textsLength);\n          removeList.forEach(function (item) {\n            self.$el.removeChild(item.el);\n          });\n        }\n      }\n\n      // destroy\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        var self = this;\n        self.interval = null;\n        // clear in TagCloud.list\n        var index = TagCloud.list.findIndex(function (e) {\n          return e.el === self.$el;\n        });\n        if (index !== -1) TagCloud.list.splice(index, 1);\n        // clear element\n        if (self.$container && self.$el) {\n          self.$container.removeChild(self.$el);\n        }\n      }\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        var self = this;\n        self.paused = true;\n      }\n    }, {\n      key: \"resume\",\n      value: function resume() {\n        var self = this;\n        self.paused = false;\n      }\n    }], [{\n      key: \"_on\",\n      value:\n      // event listener\n      function _on(el, ev, handler, cap) {\n        if (el.addEventListener) {\n          el.addEventListener(ev, handler, cap);\n        } else if (el.attachEvent) {\n          el.attachEvent(\"on\".concat(ev), handler);\n        } else {\n          el[\"on\".concat(ev)] = handler;\n        }\n      }\n    }]);\n    return TagCloud;\n  }();\n  TagCloud.list = [];\n  // default config\n  TagCloud._defaultConfig = {\n    radius: 100,\n    // rolling radius, unit `px`\n    maxSpeed: 'normal',\n    // rolling max speed, optional: `slow`, `normal`(default), `fast`\n    initSpeed: 'normal',\n    // rolling init speed, optional: `slow`, `normal`(default), `fast`\n    direction: 135,\n    // rolling init direction, unit clockwise `deg`, optional: `0`(top) , `90`(left), `135`(right-bottom)(default)...\n    keep: true,\n    // whether to keep rolling after mouse out area, optional: `false`, `true`(default)(decelerate to rolling init speed, and keep rolling with mouse)\n    useContainerInlineStyles: true,\n    useItemInlineStyles: true,\n    containerClass: 'tagcloud',\n    itemClass: 'tagcloud--item',\n    useHTML: false\n  };\n  // speed value\n  TagCloud._getMaxSpeed = function (name) {\n    return {\n      slow: 0.5,\n      normal: 1,\n      fast: 2\n    }[name] || 1;\n  };\n  TagCloud._getInitSpeed = function (name) {\n    return {\n      slow: 16,\n      normal: 32,\n      fast: 80\n    }[name] || 32;\n  };\n  var index = function (els, texts, options) {\n    if (typeof els === 'string') els = document.querySelectorAll(els);\n    if (!els.forEach) els = [els];\n    var instances = [];\n    els.forEach(function (el) {\n      if (el) {\n        instances.push(new TagCloud(el, texts, options));\n      }\n    });\n    return instances.length <= 1 ? instances[0] : instances;\n  };\n  return index;\n});\n\n//# sourceURL=webpack://portfolio/./node_modules/TagCloud/dist/TagCloud.js?");

/***/ })

}]);